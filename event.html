<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>숨은 그림 찾기</title>
    <link rel="stylesheet" href="style.css">
    <!-- Swiper CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css" />
</head>
<body>
<div id="page">
    <div class="game-container">
        <div class="background">
            <span class="target item1" data-text="모자"></span>
            <!-- <span class="target item2" data-text="우산"></span> -->
            <!-- <span class="target item3" data-text="시계"></span>
            <span class="target item4" data-text="책"></span>
            <span class="target item5" data-text="안경"></span>
            <span class="target item6" data-text="가방"></span>
            <span class="target item7" data-text="신발"></span>
            <span class="target item8" data-text="장갑"></span>
            <span class="target item9" data-text="지갑"></span>
            <span class="target item10" data-text="열쇠"></span> -->
        </div>
        <div class="timer">00:00</div>
        <div class="minimap">
            <div class="minimap-content">
                <div class="minimap-viewport"></div>
            </div>
        </div>
    </div>

    <div class="zoom-controls">
        <button class="zoom-btn" id="zoomOut">-</button>
        <button class="zoom-btn" id="zoomIn">+</button>
    </div>

    <div class="target-list">
        <div class="swiper">
            <div class="swiper-wrapper">
                <div class="swiper-slide" data-target="item1">모자</div>
                <!-- <div class="swiper-slide" data-target="item2">우산</div> -->
                <!-- <div class="swiper-slide" data-target="item3">시계</div>
                <div class="swiper-slide" data-target="item4">책</div>
                <div class="swiper-slide" data-target="item5">안경</div>
                <div class="swiper-slide" data-target="item6">가방</div>
                <div class="swiper-slide" data-target="item7">신발</div>
                <div class="swiper-slide" data-target="item8">장갑</div>
                <div class="swiper-slide" data-target="item9">지갑</div>
                <div class="swiper-slide" data-target="item10">열쇠</div>
            </div> -->
        </div>
    </div>
</div>
<div id="complete" class="complete-layer">
    <input type="text" id="name" placeholder="이름">
    <div class="phone-inputs">
        <input type="text" id="phone1" maxlength="3" placeholder="010" oninput="this.value = this.value.replace(/[^0-9]/g, ''); autoNext(this, 3, 'phone2');">
        <input type="text" id="phone2" maxlength="4" placeholder="0000" oninput="this.value = this.value.replace(/[^0-9]/g, ''); autoNext(this, 4, 'phone3');">
        <input type="text" id="phone3" maxlength="4" placeholder="0000" oninput="this.value = this.value.replace(/[^0-9]/g, '');">
    </div>
    <div class="checkbox-group">
        <input type="checkbox" id="privacy" required>
        <label for="privacy">이벤트 참여를 위한 개인정보 수집활용</label>
    </div>
    <div class="checkbox-group">
        <input type="checkbox" id="age" required>
        <label for="age">만 14세 이상입니다</label>
    </div>
    <button id="result">결과보기</button>
</div>

<div id="nickname" class="nickname-layer">
    <div class="nickname-content">
        <input type="text" id="nicknameInput" placeholder="닉네임을 입력해주세요">
        <button id="submitNickname">확인</button>
    </div>
</div>

<!-- Swiper JS -->
<script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js"></script>
<script>
    document.querySelectorAll('.target').forEach(target => {
        target.addEventListener('click', function(e) {
            // 파노라마가 진행 중이면 클릭 무시
            if (isPanoramaPlaying) {
                e.preventDefault();
                return;
            }
            
            const targetClass = this.classList[1];
            const targetSlide = document.querySelector(`.swiper-slide[data-target="${targetClass}"]`);
            if (targetSlide) {
                targetSlide.classList.add('found');
            }
            alert(this.dataset.text);
        });
    });

    const container = document.querySelector('.game-container');
    const background = document.querySelector('.background');
    const zoomButtons = document.querySelectorAll('.zoom-btn');
    const minimapViewport = document.querySelector('.minimap-viewport');

    let currentScale = 1;
    let currentX = 0;
    let currentY = 0;
    
    // 줌 레벨 관련 변수 추가
    const zoomLevels = [1, 1.3, 1.5, 2];
    let currentZoomIndex = 0;

    function updateZoom(scale) {
        const containerRect = container.getBoundingClientRect();
        
        // 현재 중심점 계산
        const centerX = (-currentX + containerRect.width / 2) / currentScale;
        const centerY = (-currentY + containerRect.height / 2) / currentScale;
        
        // 스케일 업데이트
        currentScale = scale;
        
        // background 크기 업데이트 - width만 변경
        const newWidth = Math.min(300 * window.innerWidth * scale / 100, 1440 * scale);
        background.style.width = `${newWidth}px`;
        
        // 새로운 위치 계산
        let newX = -(centerX * scale - containerRect.width / 2);
        let newY = -(centerY * scale - containerRect.height / 2);
        
        // background의 새로운 크기 가져오기
        const backgroundRect = background.getBoundingClientRect();
        
        // 경계 제한 계산
        const minX = containerRect.width - backgroundRect.width;
        const minY = containerRect.height - backgroundRect.height;
        
        // 위치 제한 적용
        if (newX > 0) newX = 0;
        if (newX < minX) newX = minX;
        if (newY > 0) newY = 0;
        if (newY < minY) newY = minY;
        
        // 위치만 적용 (scale 제외)
        currentX = newX;
        currentY = newY;
        background.style.transform = `translate(${newX}px, ${newY}px)`;
        
        requestAnimationFrame(() => {
            updateMinimapViewport();
        });
    }

    // 줌 버튼 이벤 리스너 교체
    document.getElementById('zoomIn').addEventListener('click', () => {
        if (currentZoomIndex < zoomLevels.length - 1) {
            currentZoomIndex++;
            updateZoom(zoomLevels[currentZoomIndex]);
        }
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
        if (currentZoomIndex > 0) {
            currentZoomIndex--;
            updateZoom(zoomLevels[currentZoomIndex]);
        }
    });

    // 스크롤 이벤트 리스너
    container.addEventListener('scroll', updateMinimapViewport);

    // 초기 미니맵 뷰포트 설정
    updateMinimapViewport();

    function updateMinimapViewport() {
        const containerRect = container.getBoundingClientRect();
        const backgroundRect = background.getBoundingClientRect();
        const minimapContent = document.querySelector('.minimap-content');
        const minimapRect = minimapContent.getBoundingClientRect();

        // 실제 배경 이미지의 원본 크기와 미니맵 크기의 비율 계산
        const scaleX = minimapRect.width / backgroundRect.width;
        const scaleY = minimapRect.height / backgroundRect.height;

        // 컨테이너의 실제 크기를 미니맵 스케일로 변환
        const viewportWidth = containerRect.width * scaleX;
        const viewportHeight = containerRect.height * scaleY;

        // 현재 위치를 미니맵 스케일로 변환
        const viewportX = -currentX * scaleX;
        const viewportY = -currentY * scaleY;

        minimapViewport.style.width = `${viewportWidth}px`;
        minimapViewport.style.height = `${viewportHeight}px`;
        minimapViewport.style.left = `${viewportX}px`;
        minimapViewport.style.top = `${viewportY}px`;
    }

    let isDragging = false;
    let startX, startY;
    let startPanX, startPanY;

    // 기존 변수 선언부 아래에 핀치 줌 관련 변수 추가
    let initialDistance = 0;
    let initialScale = 1;

    // 터치 이벤트 리스너에 핀치 줌 관련 코드 추가
    function startDragging(e) {
        if (e.type === 'touchstart' && e.touches.length === 2) {
            // 핀치 줌 시작
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            initialScale = currentScale;
            return;
        }

        isDragging = true;
        if (e.type === 'mousedown') {
            startX = e.clientX;
            startY = e.clientY;
        } else if (e.type === 'touchstart') {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        }
        startPanX = currentX;
        startPanY = currentY;
        background.style.cursor = 'grabbing';
    }

    function drag(e) {
        if (e.type === 'touchmove' && e.touches.length === 2) {
            // 핀치 줌 처리
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );

            const scale = (currentDistance / initialDistance) * initialScale;
            const newZoomIndex = findClosestZoomLevel(scale);
            
            if (newZoomIndex !== currentZoomIndex) {
                currentZoomIndex = newZoomIndex;
                updateZoom(zoomLevels[currentZoomIndex]);
            }
            return;
        }

        if (!isDragging) return;
        
        e.preventDefault();
        
        let clientX, clientY;
        if (e.type === 'mousemove') {
            clientX = e.clientX;
            clientY = e.clientY;
        } else if (e.type === 'touchmove') {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        }

        const deltaX = clientX - startX;
        const deltaY = clientY - startY;

        let newX = startPanX + deltaX;
        let newY = startPanY + deltaY;

        // 경계 제한 계산
        const containerRect = container.getBoundingClientRect();
        const backgroundRect = background.getBoundingClientRect();
        
        // 경계 계산
        const minX = containerRect.width - backgroundRect.width;
        const minY = containerRect.height - backgroundRect.height;
        
        // 위치 제한 적용
        if (newX > 0) newX = 0;
        if (newX < minX) newX = minX;
        if (newY > 0) newY = 0;
        if (newY < minY) newY = minY;

        currentX = newX;
        currentY = newY;

        // transform에는 translate만 적용
        background.style.transform = `translate(${currentX}px, ${currentY}px)`;
        
        // 미니맵 업데이트
        updateMinimapViewport();
    }

    function stopDragging() {
        isDragging = false;
        background.style.cursor = 'grab';
    }

    // 초기 커서 스타일 설정
    background.style.cursor = 'grab';

    // 초기 크기 설정
    updateZoom(currentScale);

    // 기존 변수 선언부 아래에 파노라마 관련 변수 추가
    let isPanoramaPlaying = false;
    const panoramaDuration = 3000; // 3초
    const panoramaDistance = -1000; // 이동할 거리 (픽셀)

    // 타이머 관련 변수 추가
    const timerElement = document.querySelector('.timer');
    let startTime;
    let timerInterval;

    // 타이머 업데이트 함수
    function updateTimer() {
        const currentTime = Date.now();
        const elapsedTime = Math.floor((currentTime - startTime) / 1000); // 초 단위로 변환
        
        // 99:59를 초과하면 타이머 정지
        if (elapsedTime >= 6000) { // 100분 = 6000초
            clearInterval(timerInterval);
            return;
        }

        const minutes = Math.floor(elapsedTime / 60);
        const seconds = elapsedTime % 60;
        
        // 두 자리 숫자로 포맷팅
        const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        timerElement.textContent = formattedTime;
    }

    // 초기 크기 설정 아래 파노라마 함수 추가
    function playPanorama() {
        if (isPanoramaPlaying) return;
        isPanoramaPlaying = true;

        const panoramaStartTime = Date.now();  // 파노라마용 시작 시간
        const startX = 0;

        function animate() {
            const elapsed = Date.now() - panoramaStartTime;
            const progress = Math.min(elapsed / panoramaDuration, 1);
            
            // easeInOut 효과 적용
            const easeProgress = progress < 0.5
                ? 2 * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;

            const newX = startX + (panoramaDistance * easeProgress);
            
            // 경계 제한 계산
            const containerRect = container.getBoundingClientRect();
            const backgroundRect = background.getBoundingClientRect();
            const minX = containerRect.width - backgroundRect.width;
            
            currentX = Math.max(minX, Math.min(0, newX));
            background.style.transform = `translate(${currentX}px, ${currentY}px)`;
            updateMinimapViewport();

            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                isPanoramaPlaying = false;
                // 파노라마가 끝난 후 이미지 위치 초기화 및 타이머 시작
                currentX = 0;
                background.style.transform = `translate(${currentX}px, ${currentY}px)`;
                updateMinimapViewport();
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 1000);
            }
        }

        requestAnimationFrame(animate);
    }

    // 페이지 로드 시 파노라마 실행
    window.addEventListener('load', () => {
        setTimeout(playPanorama, 100); // 약간의 지연을 주어 초기화 완료 후 실행
    });

    // 가장 가까운 줌 레벨을 찾는 함수 추가
    function findClosestZoomLevel(scale) {
        let closestIndex = 0;
        let minDiff = Math.abs(zoomLevels[0] - scale);

        for (let i = 1; i < zoomLevels.length; i++) {
            const diff = Math.abs(zoomLevels[i] - scale);
            if (diff < minDiff) {
                minDiff = diff;
                closestIndex = i;
            }
        }

        return closestIndex;
    }

    // 마우스 이벤트 리스너 추가
    background.addEventListener('mousedown', startDragging);
    window.addEventListener('mousemove', drag);
    window.addEventListener('mouseup', stopDragging);

    // 터치 이벤트 리스너 추가
    background.addEventListener('touchstart', startDragging, { passive: false });
    window.addEventListener('touchmove', drag, { passive: false });
    window.addEventListener('touchend', stopDragging, { passive: false });

    // Swiper 초기화
    const swiper = new Swiper('.swiper', {
        slidesPerView: 6,
        spaceBetween: 20,
        resistance: true,
        resistanceRatio: 0,
        slideToClickedSlide: true
    });

    // 클릭 이벤트 핸들러 수정
    background.addEventListener('click', function(e) {
        // 파노라마가 진행 중이면 클릭 무시
        if (isPanoramaPlaying) {
            e.preventDefault();
            return;
        }
        
        const target = e.target.closest('.target');
        
        if (target) {
            // 숨은 그림을 찾은 경우
            const targetClass = target.classList[1];
            const targetSlide = document.querySelector(`.swiper-slide[data-target="${targetClass}"]`);
            
            if (!target.classList.contains('found')) {
                target.classList.add('found');
                if (targetSlide) {
                    targetSlide.classList.add('found');
                }
                
                // 모든 아이템을 찾았는지 확인
                const foundItems = document.querySelectorAll('.target.found').length;
                const totalItems = document.querySelectorAll('.target').length;
                
                if (foundItems === totalItems) {
                    // 타이머 정지
                    clearInterval(timerInterval);
                    
                    // 최종 시간 기록
                    const finalTime = timerElement.textContent;
                    
                    // 축하 메시지 표시
                    setTimeout(() => {
                        complete(finalTime);
                    }, 500);
                }
            }
        } else {
            // 빈 공간을 클릭한 경우
            const mark = document.createElement('div');
            mark.className = 'click-mark wrong';
            mark.style.left = `${e.pageX}px`;
            mark.style.top = `${e.pageY}px`;
            mark.style.animation = 'fadeOut 0.5s ease-out forwards';
            
            document.body.appendChild(mark);
            
            // 0.5초 후 요소 제거
            setTimeout(() => {
                mark.remove();
            }, 500);
        }
    });

    function complete(finalTime) {
        const completeLayer = document.getElementById('complete');
        completeLayer.classList.add('active');
        
        // 초 단위로 변환
        const [minutes, seconds] = finalTime.split(':').map(Number);
        const totalSeconds = minutes * 60 + seconds;
        
        document.getElementById('result').addEventListener('click', async function() {
            const name = document.getElementById('name').value;
            const phone1 = document.getElementById('phone1').value;
            const phone2 = document.getElementById('phone2').value;
            const phone3 = document.getElementById('phone3').value;
            const privacy = document.getElementById('privacy').checked;
            const age = document.getElementById('age').checked;
            
            // 유효성 검사
            if (name.length < 2) {
                alert('이름을 2자 이상 입력해주세요.');
                return;
            }
            
            const phone = `${phone1}${phone2}${phone3}`;
            if (phone.length < 11) {
                alert('올바른 연락처를 입력해주세요.');
                return;
            }
            
            if (!privacy || !age) {
                alert('필수 약관에 동의해주세요.');
                return;
            }
            showNicknameLayer();
            try {
                const response = await fetch('https://{DOMAIN}/api/event-proc.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: name,
                        hphone: phone,
                        timer: totalSeconds,
                        agree1: privacy ? 'Y' : 'N',
                        agree2: age ? 'Y' : 'N'
                    })
                });
                
                if (!response.ok) {
                    throw new Error('API 호출 실패');
                }
                
                const result = await response.json();
                
                if (!result.result) {
                    // 실패 시
                    if (result.message) {
                        alert(result.message);
                    } else {
                        alert('이벤트 참여 중 오류가 발생했습니다.');
                    }
                    return;
                }
                
                // 성공 시
                let successMessage = '이벤트 참여가 완료되었습니다!';
                if (result.ranking) {
                    successMessage += `\n오늘의 순위: ${result.ranking}위`;
                }
                
                // 닉네임 입력이 필요한 경우
                if (!result.nickname) {
                    showNicknameLayer();
                } else {
                    alert(successMessage);
                    completeLayer.classList.remove('active');
                }
                
            } catch (error) {
                console.error('API 호출 중 오류 발생:', error);
                alert('이벤트 참여 중 오류가 발생했습니다. 다시 시도해주세요.');
            }
        });
    }

    // 닉네임 입력 레이어 표시 함수
    function showNicknameLayer() {
        const completeLayer = document.getElementById('complete');
        const nicknameLayer = document.getElementById('nickname');
        const name = document.getElementById('name').value;
        const phone1 = document.getElementById('phone1').value;
        const phone2 = document.getElementById('phone2').value;
        const phone3 = document.getElementById('phone3').value;
        const phone = `${phone1}${phone2}${phone3}`;
        
        nicknameLayer.classList.add('active');
        
        document.getElementById('submitNickname').addEventListener('click', async () => {
            const nickname = document.getElementById('nicknameInput').value;
            if (nickname.length < 2) {
                alert('닉네임을 2자 이상 입력해주세요.');
                return;
            }
            
            try {
                const response = await fetch('https://{DOMAIN}/api/nickname-proc.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: name,
                        hphone: phone,
                        nickname: nickname
                    })
                });
                
                if (!response.ok) {
                    throw new Error('닉네임 저장 실패');
                }
                
                const result = await response.json();
                if (result.result) {
                    // 성공 시
                    nicknameLayer.classList.remove('active');
                    alert('닉네임이 저장되었습니다. 결과보기 버튼을 클릭해주세요.');
                } else {
                    // 실패 시
                    alert(result.message || '닉네임이 중복되어 사용할 수 없습니다.');
                }
            } catch (error) {
                console.error('닉네임 저장 중 오류 발생:', error);
                alert('닉네임 저장에 실패했습니다. 다시 시도해주세요.');
            }
        });
    }

    // 자동 다음 입력창 이동 함수
    function autoNext(currentInput, maxLength, nextInputId) {
        if (currentInput.value.length >= maxLength) {
            document.getElementById(nextInputId).focus();
        }
    }
</script>
</body>
</html>